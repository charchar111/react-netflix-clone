# react-nomflix-clone

## 컨셉

넷플릭스에서 영감을 받은 이 프로젝트는
- 유명한 영화와 드라마의 정보를 제공
- 부드러운 화면 전환 방식과 상호작용, 애니메이션 등 유저의 경험 개선
  에 중점을 두었습니다.

## Link

https://charchar111.github.io/react-netflix-clone/

#### 주의사항
브라우저 라우터를 사용한 관계로 github에 배포된 사이트에서는 새로고침 시, 404가 뜰 수 있습니다. / url 에서만 새로고침을 해주시면 됩니다.

## 기술 스택
- React
- [styled-component](#스타일-컴포넌트와-atomic-컴포넌트-디자인-패턴)
- [Recoil](#Recoil-redux와의-비교)
- [framer-motion](#Client-side-routing과-애니메이션)
- [react-query](#데이터-캐싱)

## 세부사항
### 스타일 컴포넌트와 atomic 컴포넌트 디자인 패턴
- 스타일 컴포넌트는 스타일링한 요소를 커스텀 컴포넌트로 만드는데 특화되어 있습니다. 따라서, 커스텀이 자유로운 공용 컴포넌트를 만들어 생산성과 유지보수의 이점을 가지는 것이 목적입니다.
- 여기서는 atomic 디자인 패턴을 참고하여 컴포넌트의 단계를 atom, molecule, organism으로 나누었습니다.
- atom | 가장 기본 단위의 html 요소로 button, input 등을 말하지만, 이 자체로는 특정한 목적을 가지고 있지 않습니다.
- molcule | atom의 조합물로, 단일한 목적을 가지고 있습니다.(로그인 폼, 검색 바, 탭, 리스트)
- organism | atom과 molcule의 조합물로, header, footer처럼 특정한 위치와 맥락에서 사용됩니다. 특정 맥락을 위한 컴포넌트이기 때문에 재사용성이 낮습니다.
- [참고 자료. 카카오 엔터테이먼트- 아토믹 디자인을 활용한 디자인 시스템 도입기](https://fe-developers.kakaoent.com/2022/220505-how-page-part-use-atomic-design-system/)

- 워크 플로우 | 계획 단계에서는 페이지 내 모든 요소를 최대한 organism으로 환원합니다. 이후, 각 페이지에서 공통되는 목적의 ui를 molcule로 환원하고 실질적으로 공통된 요소는 atom으로 분할합니다.

### Recoil-redux와의 비교
flux 디자인 패턴인 react에서는 컴포넌트 간에 중첩 관계가 복잡해질수록 상위 컴포넌트에서 하위 컴포넌트로 props를 전달하는 문제인 props drilling이 심화됩니다. 그 대안으로 상태 관리 라이브러리를 사용해야 하는데, 이 때 주로 비교되는 것이 단일 스토어인 redux와 분할 스토어인 recoil입니다. redux는 디버깅에 용이한 dev tool을 가지고 있고 다양한 기능을 가지고 있으나, 초기 세팅 단계에서 복잡한 코드를 작성하는 데 시간을 소모한다는 단점이 있습니다. 반면, recoil은 초기 세팅이 정말 간단하고 react의 state와 가장 유사한 상태 관리 패턴을 가지고 있어서 규모가 작은 프로젝트에서 생산성과 유지 보수 면에 우수합니다.
이 프로젝트의 규모가 크지 않다는 점, 그리고 향후 redux와의 비교를 위해서 recoil을 채택했습니다.

### Client side routing과 애니메이션
framer-motion은 최적화된 애니메이션을 사용가능하고 직관적인 API를 가진 라이브러리일 뿐만 아니라 CSR과 styled-component와의 결합에서 큰 장점을 가지고 있습니다.

- framer-motion은 styled-component와 통합이 간편하며, styled-component의 함수 및 변수 기능을 제한하지 않습니다.
- 이 프로젝트는 라우트가 변경되는 과정에서 ui에 애니메이션을 부여하여 부드러운 앱을 만드는 것이 목적이었습니다. framer-motion은 AnimatePresence와 Layout 훅을 이용해서 이 기능을 쉽게 구현가능합니다.
    - ex) 홈 라우트에서 영화 그림을 클릭하면 url이 변경되면서 모달창을 띄우는 애니메이션이 발생

### 데이터 캐싱
대량의 코인 정보를 요청하는 앱의 특성 상, 동일한 정보를 중복 요청하지 않기 위한 캐싱 기능이 필수적이었고 그런 점에서 react-query를 채택하였습니다. 물론, 캐싱 기능이나 에러 핸들링, 로딩 스테이트는 직접 구현이 가능한 사항입니다만, 이후 프로젝트의 확장 가능성을 고려한다면 mutation 등의 다양한 기능을 가진 react-query를 사용하는 것이 가독성이나 기능면에서 더 우수합니다.

## 추가 계획
### skeleton-ui
대량의 데이터를 받아 렌더링 하는 사이트 특성 상, 유저에게 데이터가 로딩되고 있음을 알려줄 ui가 중요합니다. 때문에, 스켈레톤 ui를 넣어서 로딩 시간 동안의 유저 이탈을 막을 계획입니다.

## 이슈 & 해결방안
### 이벤트 버블링에 의해 중첩된 ui 간의 이벤트 오류 문제
#### 문제
- 이 프로젝트의 주요 소스인 넷플릭스는 검색창을 클릭해서 연 후, 닫을 때는 검색 창 외의 아무 곳을 클릭해도 닫을 수 있다. 이처럼 body를 클릭하여 확장된 ui를 원상태로 돌리는 이벤트는 넷플릭스 외의 사이트에서도 흔히 보이는 패턴입니다.
- 이를 구현하기 위해 isOpenSearchbar 상태값을 생성합니다. 그리고 서치바를 클릭할 때는 이 값이 true로 변경되며 동적으로 서치바의 스타일을 변경하고 확장시킵니다. 반면, body를 클릭하면 상태값이 false로 변경되며 ui를 닫힌 상태로 변경합니다.
- 그러나 실제 실행 결과, 서치바는 열리지 않았습니다.

#### 분석 및 해결방안
- state 변경은 비동기적으로 요청되고 다른 state 변경 요청과 일괄적으로 함께 처리됩니다.
- 서치바 클릭 이벤트는 이벤트 버블링에 의해 body의 클릭 이벤트까지 트리거합니다.
- 서치바 클릭 이벤트에서 isOpenSearchbar을 true로 변경했지만, 연달아 발생한 body의 클릭 이벤트로 다시 false로 변경되면서 ui가 확장되지 않았던 것이 원인이었습니다.
- 문제 해결을 위해서, body의 클릭이벤트는 event.target이 서치바 컴포넌트, 혹은 컴포넌트 내부의 다른 요소인지를 확인합니다. 만약, 해당 서치바를 클릭한 경우라면 isOpenSearchbar를 false로 바꾸는 이벤트를 실행하지 않습니다.

## 배운 점
- 스타일 컴포넌트와 atomic 디자인 패턴을 이용하여 공용 컴포넌트를 만드는 패턴
- 이벤트 버블링에 따른 중첩된 요소 간의 이벤트 꼬임 문제를 해결하는 간단한 방식으로서 event.target과 event.currentTarget 조건문 코드
- 클라이언트 사이드 라우팅에서 애니메이션을 넣는 방법으로 framer-motion의 이용방법

